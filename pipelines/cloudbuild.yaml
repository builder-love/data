# cloudbuild.yaml (Networked Build)
availableSecrets:
  secretManager:
  - versionName: projects/$PROJECT_ID/secrets/cloud_sql_user/versions/latest
    env: 'DB_USER'
  - versionName: projects/$PROJECT_ID/secrets/cloud_sql_password/versions/latest
    env: 'DB_PASSWORD'
  - versionName: projects/$PROJECT_ID/secrets/cloud-sql-proxy-key/versions/latest
    env: 'SA_KEY'

steps:

# 1. Create a dedicated network for the build process.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Create Network'
  args: ['network', 'create', 'dbt-build-net']

# 2. Start the Cloud SQL Proxy in its own container on the new network.
# We use the official proxy image.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Start Proxy Container'
  secretEnv: ['SA_KEY']
  entrypoint: 'bash'
  args:
  - -c
  - |
    # ðŸ’¡ 3. Write the secret to a file that can be mounted
    echo "$$SA_KEY" > sa_key.json

    # ðŸ’¡ 4. Run the proxy, mounting the key file and adding the --credentials-file flag
    docker run \
      -d \
      --name proxy-service \
      --network dbt-build-net \
      -v $(pwd)/sa_key.json:/key.json:ro \
      gcr.io/cloud-sql-connectors/cloud-sql-proxy \
      --credentials-file=/key.json \
      data-pipelines-450611:us-central1:builder-love \
      --address=0.0.0.0 \
      --port 5432
  waitFor: ['Create Network']
  # This step runs in the background, but we will wait for it to finish in the next step

# 3. Wait for the proxy container to be network-ready.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Wait for Proxy'
  entrypoint: 'bash'
  args:
  - -c
  - |
    for i in {1..10}; do
      # We run a temporary container on the same network to test DNS resolution
      if docker run --rm --network=dbt-build-net alpine ping -c 1 proxy-service; then
        echo "Proxy is reachable."
        exit 0
      fi
      echo "Waiting for proxy DNS... attempt $$i"
      sleep 2
    done
    echo "Proxy was not reachable after 20 seconds."
    exit 1
  waitFor: ['Start Proxy Container']

- name: 'gcr.io/cloud-builders/docker'
  id: 'Debug Proxy State'
  entrypoint: 'bash'
  # ðŸ’¡ Add secrets needed for the psql connection test
  secretEnv: ['DB_USER', 'DB_PASSWORD']
  args:
  - -c
  - |
    set -e # Exit immediately if a command fails
    echo "Waiting 5 seconds for proxy to be fully ready..."
    sleep 5
    
    echo "--- 1. Checking Proxy Container Status ---"
    docker ps -a
    
    PROXY_IP=$$(docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' proxy-service)
    echo "Proxy IP is $$PROXY_IP"
    
    echo "\n--- 2. Scanning Port 5432 on Proxy Container ---"
    docker run --rm --network=dbt-build-net instrumentisto/nmap -p 5432 $$PROXY_IP
    
    echo "\n--- 3. Retrieving Proxy Container Logs ---"
    docker logs proxy-service

    # # ðŸ’¡ New connection test logic starts here
    # echo "\n--- 4. Testing Live DB Connection via Proxy ---"
    
    # echo "Installing PostgreSQL client..."
    # apt-get update >/dev/null && apt-get install -y postgresql-client >/dev/null
    
    # # Set the password for the psql client to use
    # export PGPASSWORD=$$DB_PASSWORD
    
    # echo "Attempting to connect to $$PROXY_IP:5432 and run 'SELECT 1'..."
    # psql -h $$PROXY_IP -p 5432 -U $$DB_USER -d postgres -c "SELECT data_timestamp from raw_stg.latest_project_repos_documentation_files limit 1;"
    
    # echo "--- Live DB Connection Test Succeeded ---"
  waitFor: ['Wait for Proxy']

# 4. Get the IP address of the running proxy container.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Get Proxy IP'
  entrypoint: 'bash'
  args:
    - -c
    - |
      docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' proxy-service > /workspace/proxy_ip.txt
  waitFor: ['Debug Proxy State']

# 5. Create the .env file in the build context.
- name: 'bash'
  id: 'Create .env File'
  secretEnv: ['DB_USER', 'DB_PASSWORD']
  args:
    - -c
    - |
      # Read the IP address from the file created in the previous step
      PROXY_IP=$(cat /workspace/proxy_ip.txt)
      echo "--- Using Proxy IP: $$PROXY_IP ---"
      cat <<EOT > pipelines/.env
      cloud_sql_user=$$DB_USER
      cloud_sql_password=$$DB_PASSWORD
      cloud_sql_postgres_db=postgres
      cloud_sql_postgres_host=$$PROXY_IP
      EOT
  waitFor: ['Get Proxy IP']

# 6. Build the main application image.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Build App Image'
  secretEnv: ['DB_USER', 'DB_PASSWORD']
  args: [
    'build',
    # Attach this build to our custom network
    '--network=dbt-build-net',
    '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA',
    '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:latest',
    './pipelines'
  ]
  waitFor: ['Create .env File'] # Ensure proxy is started before building

# 7. Stop and remove the proxy container (important for cleanup).
- name: 'gcr.io/cloud-builders/docker'
  id: 'Stop Proxy Container'
  args: ['rm', '-f', 'proxy-service']
  # This step runs even if the build fails, ensuring cleanup.
  waitFor: ['Build App Image']

# 8. Push the final image.
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app', '--all-tags']
  waitFor: ['Stop Proxy Container'] # Wait for build and cleanup

# Deploy the new image to your GKE cluster.
- name: 'gcr.io/cloud-builders/gke-deploy'
  args:
  - 'run'
  - '--filename=pipelines/k8s/'
  - '--image=us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app=us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA'
  - '--location=us-central1-c'
  - '--cluster=dagster-cluster'

images:
- 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA'
- 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:latest'

options:
  logging: CLOUD_LOGGING_ONLY