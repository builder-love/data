# cloudbuild.yaml
availableSecrets:
  secretManager:
  - versionName: projects/$PROJECT_ID/secrets/cloud_sql_user/versions/latest
    env: 'DB_USER'
  - versionName: projects/$PROJECT_ID/secrets/cloud_sql_password/versions/latest
    env: 'DB_PASSWORD'
  - versionName: projects/$PROJECT_ID/secrets/gcp_project_id/versions/latest
    env: 'GCP_PROJECT_ID'
  - versionName: projects/$PROJECT_ID/secrets/go_blockchain_ecosystem/versions/latest
    env: 'GH_PAT'
  - versionName: projects/$PROJECT_ID/secrets/bitbucket_api_key/versions/latest
    env: 'BB_KEY'

steps:
# A single, unified step to handle the proxy, .env creation, and docker build
- name: 'gcr.io/cloud-builders/docker' # Use the docker builder as the base
  id: 'Proxy-Env-and-Build'
  entrypoint: 'bash'
  secretEnv: ['DB_USER', 'DB_PASSWORD', 'GCP_PROJECT_ID', 'GH_PAT', 'BB_KEY']
  env:
  - 'DAGSTER_ENV=stg'
  - 'DAGSTER_HOME=/opt/dagster/app'
  - 'DB_NAME=postgres'
  - 'DB_HOST=127.0.0.1'
  args:
  - '-c'
  - |
    set -e # Exit immediately if a command fails

    # Part 1: Install curl in the docker builder container
    apk add --no-cache curl

    # Part 2: Download and start the proxy in the background
    echo "--- Starting Proxy ---"
    curl -o cloud-sql-proxy "https://storage.googleapis.com/cloud-sql-proxy/v2/cloud-sql-proxy.linux.amd64"
    chmod +x cloud-sql-proxy
    # The proxy can bind to localhost here since all commands are in the same step
    ./cloud-sql-proxy --structured-logs --health-check data-pipelines-450611:us-central1:builder-love &
    
    # Part 3: Wait for the proxy to be healthy
    echo "--- Waiting for proxy health check ---"
    sleep 5 # Give it a moment to initialize
    for i in {1..20}; do
      # Use the -s (silent) flag for curl in the loop
      if curl -s http://127.0.0.1:9090/ready; then
        echo "Proxy is ready!"
        break
      fi
      if [ $i -eq 20 ]; then
        echo "Proxy did not become ready in time"
        exit 1
      fi
      echo "Proxy not ready, waiting..."
      sleep 1
    done

    # Part 4: Create the .env file
    echo "--- Creating .env file ---"
    # Using a heredoc is cleaner for multi-line files
    cat <<EOT > pipelines/.env
    DAGSTER_ENV=$DAGSTER_ENV
    DAGSTER_HOME=$DAGSTER_HOME
    cloud_sql_postgres_db=$DB_NAME
    cloud_sql_postgres_host=$DB_HOST
    cloud_sql_user=$$DB_USER
    cloud_sql_password=$$DB_PASSWORD
    gcp_project_id=$$GCP_PROJECT_ID
    go_blockchain_ecosystem=$$GH_PAT
    bitbucket_api_key=$$BB_KEY
    EOT

    # Part 5: Run the docker build
    echo "--- Building Docker image ---"
    docker build \
      -t us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA \
      -t us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:latest \
      ./pipelines

# 5. Push the built image to Artifact Registry.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Push-Image'
  waitFor: ['Proxy-Env-and-Build']
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app', '--all-tags']

# 6. Deploy the new image to your GKE cluster.
- name: 'gcr.io/cloud-builders/gke-deploy'
  id: 'Deploy-Image'
  waitFor: ['Push-Image']
  args:
  - 'run'
  - '--filename=pipelines/k8s/'
  - '--image=us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app=us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA'
  - '--location=us-central1-c'
  - '--cluster=dagster-cluster'

images:
- 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA'
- 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:latest'

options:
  logging: CLOUD_LOGGING_ONLY