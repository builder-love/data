# cloudbuild.yaml (Networked Build)
availableSecrets:
  secretManager:
  - versionName: projects/$PROJECT_ID/secrets/cloud_sql_user/versions/latest
    env: 'DB_USER'
  - versionName: projects/$PROJECT_ID/secrets/cloud_sql_password/versions/latest
    env: 'DB_PASSWORD'

steps:

# 1. Create a dedicated network for the build process.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Create Network'
  args: ['network', 'create', 'dbt-build-net']

# 2. Start the Cloud SQL Proxy in its own container on the new network.
# We use the official proxy image.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Start Proxy Container'
  args: [
    'run',
    '-d',
    '--name', 'proxy-service',
    '--network', 'dbt-build-net',
    'gcr.io/cloud-sql-connectors/cloud-sql-proxy',
    'data-pipelines-450611:us-central1:builder-love'
  ]
  # This step runs in the background, but we will wait for it to finish in the next step

# 3. Wait for the proxy container to be network-ready.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Wait for Proxy'
  entrypoint: 'bash'
  args:
  - -c
  - |
    for i in {1..10}; do
      # We run a temporary container on the same network to test DNS resolution
      if docker run --rm --network=dbt-build-net alpine ping -c 1 proxy-service; then
        echo "Proxy is reachable."
        exit 0
      fi
      echo "Waiting for proxy DNS... attempt $$i"
      sleep 2
    done
    echo "Proxy was not reachable after 20 seconds."
    exit 1
  waitFor: ['Start Proxy Container']

# # 5. Get the IP address of the running proxy container.
# - name: 'gcr.io/cloud-builders/docker'
#   id: 'Get Proxy IP'
#   entrypoint: 'bash'
#   args:
#     - -c
#     - |
#       docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' proxy-service > /workspace/proxy_ip.txt
#   waitFor: ['Start Proxy Container']

  # 4. Create the .env file in the build context.
- name: 'bash'
  id: 'Create .env File'
  secretEnv: ['DB_USER', 'DB_PASSWORD']
  args:
    - -c
    - |
      cat <<EOT > pipelines/.env
      cloud_sql_user=$$DB_USER
      cloud_sql_password=$$DB_PASSWORD
      cloud_sql_postgres_db=postgres
      cloud_sql_postgres_host=proxy-service
      EOT
  waitFor: ['Wait for Proxy']

# 5. Build the main application image.
- name: 'gcr.io/cloud-builders/docker'
  id: 'Build App Image'
  secretEnv: ['DB_USER', 'DB_PASSWORD']
  args: [
    'build',
    # Attach this build to our custom network
    '--network=dbt-build-net',
    '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA',
    '-t', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:latest',
    './pipelines'
  ]
  waitFor: ['Wait for Proxy'] # Ensure proxy is started before building

# 6. Stop and remove the proxy container (important for cleanup).
- name: 'gcr.io/cloud-builders/docker'
  id: 'Stop Proxy Container'
  args: ['rm', '-f', 'proxy-service']
  # This step runs even if the build fails, ensuring cleanup.
  waitFor: ['Build App Image']

# 7. Push the final image.
- name: 'gcr.io/cloud-builders/docker'
  args: ['push', 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app', '--all-tags']
  waitFor: ['Stop Proxy Container'] # Wait for build and cleanup

# Deploy the new image to your GKE cluster.
- name: 'gcr.io/cloud-builders/gke-deploy'
  args:
  - 'run'
  - '--filename=pipelines/k8s/'
  - '--image=us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app=us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA'
  - '--location=us-central1-c'
  - '--cluster=dagster-cluster'

images:
- 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:$SHORT_SHA'
- 'us-central1-docker.pkg.dev/$PROJECT_ID/dagster-repo/dagster-app:latest'

options:
  logging: CLOUD_LOGGING_ONLY